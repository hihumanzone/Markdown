<!DOCTYPE html>
<html>
<head>
    <title>Test Duplicate Titles Fix</title>
</head>
<body>
<h1>Test Duplicate Titles Fix</h1>
<div id="test-results"></div>

<script>
// Simulate the relevant classes and functions from the main app with the fix
class TestSavedSectionsManager {
    constructor() {
        this.STORAGE_KEYS = {
            HISTORY: 'markdownHistoryTest'
        };
        this.MAX_HISTORY_ITEMS = 5;
    }
    
    extractTitle(content) {
        const lines = content.split('\n');
        for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed.startsWith('# ')) {
                return trimmed.substring(2).trim();
            }
            if (trimmed.startsWith('## ')) {
                return trimmed.substring(3).trim();
            }
            if (trimmed && !trimmed.startsWith('#') && trimmed.length < 100) {
                return trimmed;
            }
        }
        return null;
    }
    
    generateUniqueHistoryTitle(baseTitle, content, history) {
        // Find all existing items with the same base title
        const conflictingItems = history.filter(item => 
            item.title === baseTitle || 
            item.title.startsWith(baseTitle + ' (') ||
            baseTitle.startsWith(item.title + ' (')
        );
        
        if (conflictingItems.length === 0) {
            return baseTitle;
        }
        
        // For each conflicting item, try to create unique titles based on differing content
        for (const conflictingItem of conflictingItems) {
            if (conflictingItem.content === content) {
                // Same content, keep the existing title
                return conflictingItem.title;
            }
            
            // Find the first significant difference in content
            const uniqueSuffix = this.findContentDifference(content, conflictingItem.content);
            if (uniqueSuffix) {
                const newTitle = `${baseTitle} (${uniqueSuffix})`;
                // Make sure this new title doesn't conflict with existing ones
                const titleExists = history.some(item => item.title === newTitle);
                if (!titleExists) {
                    return newTitle;
                }
            }
        }
        
        // Fallback: use a numbered suffix if we can't find meaningful differences
        let counter = 2;
        let candidateTitle = `${baseTitle} (${counter})`;
        while (history.some(item => item.title === candidateTitle)) {
            counter++;
            candidateTitle = `${baseTitle} (${counter})`;
        }
        
        return candidateTitle;
    }
    
    findContentDifference(content1, content2) {
        // Normalize content by removing extra whitespace and splitting into meaningful chunks
        const normalize = (text) => text.trim().replace(/\s+/g, ' ');
        const normalized1 = normalize(content1);
        const normalized2 = normalize(content2);
        
        // Find the first significant word or phrase where they differ
        const words1 = normalized1.split(' ');
        const words2 = normalized2.split(' ');
        
        // Find the first differing word
        for (let i = 0; i < Math.max(words1.length, words2.length); i++) {
            const word1 = words1[i] || '';
            const word2 = words2[i] || '';
            
            if (word1 !== word2) {
                // Found a difference, extract a meaningful snippet
                if (word1 && word1.length > 2) {
                    // Take this word and maybe the next one for context
                    const snippet = words1.slice(i, Math.min(i + 2, words1.length)).join(' ');
                    if (snippet.length > 2 && snippet.length <= 30) {
                        return snippet;
                    }
                }
                break;
            }
        }
        
        // Fallback: try to find unique content from the beginning
        const lines1 = content1.split('\n').filter(line => line.trim());
        const lines2 = content2.split('\n').filter(line => line.trim());
        
        for (let i = 0; i < Math.max(lines1.length, lines2.length); i++) {
            const line1 = lines1[i] || '';
            const line2 = lines2[i] || '';
            
            if (line1 !== line2 && line1.length > 0) {
                // Extract a meaningful part of this line
                const words = line1.trim().split(' ');
                if (words.length > 0) {
                    const snippet = words.slice(0, Math.min(3, words.length)).join(' ');
                    if (snippet.length > 2 && snippet.length <= 30) {
                        return snippet;
                    }
                }
            }
        }
        
        return null;
    }
    
    addToHistory(section) {
        const history = this.getHistory();
        const existingItem = history.find(item => item.content === section.content);
        
        let updatedHistory;
        if (existingItem) {
            // Same content exists, just update the timestamp and move to top
            updatedHistory = history.filter(item => item.content !== section.content);
            updatedHistory.unshift({
                id: existingItem.id,
                title: existingItem.title,
                content: existingItem.content,
                viewedAt: new Date().toISOString()
            });
        } else {
            // New content, generate a unique title
            const uniqueTitle = this.generateUniqueHistoryTitle(section.title, section.content, history);
            updatedHistory = history.filter(item => item.id !== section.id);
            updatedHistory.unshift({
                id: section.id,
                title: uniqueTitle,
                content: section.content,
                viewedAt: new Date().toISOString()
            });
        }
        
        this.setHistory(updatedHistory.slice(0, this.MAX_HISTORY_ITEMS));
        return updatedHistory;
    }
    
    getHistory() {
        try {
            return JSON.parse(localStorage.getItem(this.STORAGE_KEYS.HISTORY) || '[]');
        } catch (e) {
            return [];
        }
    }
    
    setHistory(history) {
        try {
            localStorage.setItem(this.STORAGE_KEYS.HISTORY, JSON.stringify(history));
        } catch (e) {
            console.error('Error saving history:', e);
        }
    }
    
    clearHistory() {
        localStorage.removeItem(this.STORAGE_KEYS.HISTORY);
    }
}

// Test the fix
function testDuplicateTitlesFix() {
    const manager = new TestSavedSectionsManager();
    manager.clearHistory(); // Start with clean slate
    
    // Test case 1: Same starting sentence, different content
    const content1 = "This is my first document.\nThis document talks about cats and their behavior.";
    const content2 = "This is my first document.\nThis document talks about dogs and their training.";
    const content3 = "This is my first document.\nThis document discusses programming concepts.";
    
    const title1 = manager.extractTitle(content1);
    const title2 = manager.extractTitle(content2);
    const title3 = manager.extractTitle(content3);
    
    console.log("Original titles:", title1, title2, title3);
    
    // Add all to history
    const item1 = {
        id: 'test_1',
        title: title1 || 'Untitled',
        content: content1,
        viewedAt: new Date().toISOString()
    };
    
    const item2 = {
        id: 'test_2',
        title: title2 || 'Untitled',
        content: content2,
        viewedAt: new Date().toISOString()
    };
    
    const item3 = {
        id: 'test_3',
        title: title3 || 'Untitled',
        content: content3,
        viewedAt: new Date().toISOString()
    };
    
    manager.addToHistory(item1);
    manager.addToHistory(item2);
    manager.addToHistory(item3);
    
    const history = manager.getHistory();
    console.log("Final history:", history);
    
    // Test case 2: Add same content again (should not create duplicate)
    const duplicateItem = {
        id: 'test_duplicate',
        title: title1 || 'Untitled',
        content: content1,
        viewedAt: new Date().toISOString()
    };
    
    manager.addToHistory(duplicateItem);
    const historyAfterDuplicate = manager.getHistory();
    
    // Display results
    const results = document.getElementById('test-results');
    results.innerHTML = `
        <h2>Test Results - After Fix:</h2>
        <h3>Test Case 1: Different content, same starting title</h3>
        <p><strong>Content 1:</strong> ${content1}</p>
        <p><strong>Content 2:</strong> ${content2}</p>
        <p><strong>Content 3:</strong> ${content3}</p>
        <p><strong>Original extracted title:</strong> ${title1}</p>
        
        <h4>Final History (should have unique titles):</h4>
        <ul>
            ${history.map(item => `<li><strong>${item.title}</strong> - ${item.content.substring(0, 50)}...</li>`).join('')}
        </ul>
        
        <h3>Test Case 2: Adding duplicate content</h3>
        <p><strong>History length before duplicate:</strong> ${history.length}</p>
        <p><strong>History length after adding duplicate:</strong> ${historyAfterDuplicate.length}</p>
        <p><strong>Should remain the same:</strong> ${history.length === historyAfterDuplicate.length ? 'PASS' : 'FAIL'}</p>
        
        <h3>Verification:</h3>
        <p><strong>All titles are unique:</strong> ${checkUniqueHistoryTitles(history) ? 'PASS' : 'FAIL'}</p>
        <p><strong>Titles are meaningful:</strong> ${checkMeaningfulTitles(history) ? 'PASS' : 'FAIL'}</p>
    `;
}

function checkUniqueHistoryTitles(history) {
    const titles = history.map(item => item.title);
    const uniqueTitles = new Set(titles);
    return titles.length === uniqueTitles.size;
}

function checkMeaningfulTitles(history) {
    return history.every(item => 
        item.title && 
        item.title.length > 0 && 
        !item.title.includes('undefined') && 
        (item.title.includes('(') || !history.some(other => 
            other.id !== item.id && other.title === item.title
        ))
    );
}

// Run test when page loads
testDuplicateTitlesFix();
</script>
</body>
</html>